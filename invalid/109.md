Fantastic Corduroy Shark

high

# `pullFromLocker` causes less yield to be forwarded

## Summary
The `pullFromLocker` sets basis to zero which will prevent new yield from distribution.
## Vulnerability Detail
The forwardYield function is called every 30 days by a keeper and forwards yield generated by LP to OCT_YDL. The yield that is sent is equal to the amount that the LP belonging to the OCL_ZVE is worth now in asset tokens compared to the basis. However when pullFromLocker is called by the DAO, basis is set to zero:
https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L242
As a result if forwardYield has been last called 20 days ago, the yield from our LP position, accumulated for these 20 days, will not be distributed.
## Impact
Systematical mistake in the distribution of yield causing multiple entities to earn less yield.
## Code Snippet
https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L242
## Tool used

Manual Review

## Recommendation
Distibute yield before pulling from locker:
```diff
 function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {
+        (uint256 amountToForward, uint256 lpCurrent) = fetchBasis();
+        if (amountToForward > basis) _forwardYield(amountToForward, lpCurrent);
+        (basis,) = fetchBasis();
        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();
        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);

        (uint256 amountAMin, uint256 amountBMin) = abi.decode(data, (uint256, uint256));

        // "pair" represents the liquidity pool token (minted, burned).
        // "pairAsset" represents the stablecoin paired against $ZVE.
        if (asset == pair) {
            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));
            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);

            // Router removeLiquidity() endpoint.
            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(
                pairAsset, ZVE, preBalLPToken, amountAMin, amountBMin, address(this), block.timestamp + 14 days
            );
            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);
            assert(IERC20(pair).allowance(address(this), router) == 0);

            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));
            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));
            basis = 0;
        } else {
            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));
        }
    }
```